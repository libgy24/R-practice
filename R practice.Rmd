---
title: "R Basics"
output: html_document
---

# 2. Data Structures

## 2.1 Vectors

Two different types of vectors: 
1. atomic vector: all elements of atomic vector must be the same type.
2. list: ELements can have different data types.

### 2.1.1 Atomic vectors

There are 4 common types of atomic vectors:
1. Logical
2. Integers
3. Double (often called numeric)
4. Character 

```{r, echo=TRUE}
dbl_var <- c(1, 2.5, 4.5)

# with the L suffix, you get an integer rahter a double

int_var <-c(1L,6L, 10L)

# Use TRUE and FALSE ( or T and F) to create logical vectors
log_Var <- c(TRUE, FALSE, TRUE)

chr_var <- c('these are', 'some strings')
```

Missing values are specified with NA, which is a logical vector of length 1. NA wiil always be coerced to thye correct type if used inside c(), or you can create NAs of a specific type with NA_real_(a double vector), NA_integer_ and NA_character_

#### 2.1.1.1 Types and tests

Given a vector, you can determine its type with typeof(), or check if it's a specific type with an 'is' function.
is.charachter(), is.double(), is.integer(), is.logical(), or , more generally, is.atomic().

```{r, echo=TRUE}

int_var <- c(1L, 6L, 10L)
typeof(int_var)

is.integer(int_var)

is.atomic(int_var)

dbl_var<-c(1, 2.5, 4.5)
typeof(dbl_var)

is.double(dbl_var)

is.atomic(dbl_var)
```

NB: is.numeric() is a general test for the 'numberliness' of a vector and returns TRUE for both integer and double vecotrs. It is not a specific test for double vectors.

```{r echo = TRUE}
is.numeric(int_var)

is.numeric(dbl_var)
```

#### 2.1.1.2 Coercion

All element sof an atomic vector must be the same type, so when you attempt to combine different type they will be coerced to the most flexible type. Types from least to most flexible are: logical, integer, double, and character.
Explicitly coerce with as.character(), as.double(), as.integer() or as.logical()

### 2.1.2 Lists

Lists are different from atomic vectors becasuse their elements can be of any type, including lists. You construct lists by using list() instead of c():

```{r echo=TRUE}
x<- list(1:3, 'a',c(T, F, T), c(2.3,5.9))
str(x)

```

Lists are somethimes called recursive vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors.


```{r echo = TRUE}
x<-list(list(list()))
str(x)
is.recursive(x)
```

c() will combine several lists into one. If given a combination of a atomic vectors and lists , c() will coerce the vectors to lists before combining them. Compare the results of list() and c():

```{r echo=TRUE}
x<-list(list(1,2),c(3,4))

y<-c(list(1,2),c(3,4))

x
str(x)

y
str(y)
  
```

The typeof() a list is list. You can test for a list with is.list() and coerce to alist with as.list(). You can turn a list onto an atomic vector with unlist(), If the elements of a list have different types, unlist() uses the same coercion rules as c()

Lists are used to build up many of the more complicated data structures in R, FOr example, both data framesand linear model objects are lists.

## 2.2 Attributes

All objects can have arbitrary additional attributes, used to store metadata about the object. Attributes can be thought of as a named list ( with unique names). Atributes can be accessed individually with attr() or all at once (as a list) with attributes()


```{r, echo=TRUE}
y<-1:10

attr(y, 'my_attribute')<-"This is a vector"

str(attributes(y))
```

The structure() function returns a new object with modified attributes:

```{r, echo = TRUE}
structure(1:10, data_type = "This is a vector")
```

By default, most attributes are lost when modifying a vector.

```{r, echo = TRUE}
attributes(y[1])

attributes(sum(y))
```

The only attributes not lost are the three most important:

1. Names, a character vector giving each element a name.
2. Dimensions, used to turn vectores into matrices and arrays.
3. Class, used to implement the S3 object system.

Each of these attributes has a specific accwssor function to get and set values. When working with these attributes,  use names(x), dim(x) and class(x), not attr(x,'names'), attr(x,'dim') and attr(x, 'class')



#### 2.2.0.1 Names

You can name a vector in three ways:

1. When creating it: x<-c(a=1,b=2,c=3)
2. BY modifyying an existing vector in place: x<-1:3;names(x)<-c('a','b','c')
3. By creating a modified copy of a vector: x<-setNames(1:3,c('a','b','c'))

Not all elements of a vector need to have a name. If some names are missing. names() will return an empty string for those elements. If all names are missing, names(0 will return NULL.

```{r, echo = TRUE}
y<-c(a=1, 2,3)
names(y)

z<-c(1,2,3)

names(z)
```

You can create a new vector without names using unname(x), or remove names in place with names(x)<-NULL

### 2.2.1 Factors

One important use of attributes is to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data.  Factors are built on top of integer vectors using two attributes: the class(),
'factor', which makes them behave differently from regular integer vectors. and the levels(), which defines the set of allow values.

```{r, echo = TRUE}
x <- factor(c('a','b','a','b'))
x
class(x)
levels(x)

# you cannot use values that are not in the levels.
x[2]<-'c'

x

# you cannot combine factors
c_test<-c(factor('a'),factor('b'))

```

Factors are useful when you know the possible values a variable may take, even if you don't see all values in a given dataset . Using a factor instead of a charactro vector makes it obvious when some groups contains no observations.

```{r, echo=TRUE}
sex_char<-c('m','m','m')

sex_factor<-factor(sex_char,levels=c('m','f'))

table(sex_char)

table(sex_factor)
```

Sometimes when a data frame is read directly from a file, a column you'd thought would produce a numeric vector instead produces a factor. This is caused by a non=numeric value in the column, often a missing value encode in a special way like "." or"-". To remedy the situation , coerce the vector from a factor to a character vector, and then from a character to a double vector.(Be sure to check for missing values after this process.)  Of course, a much better plan is to discover what caused the problem in the first place and fix that; usin the na.strings rgument to read.csv()  is often a good place to start.

## 2.3 Matrices and arrays

Adding a dim() attribute to an atomic vector allows it to behave like a multi-dimensional array. A special case of the array is the matrix. Which has two dimensions. Matrices are used commonly as part of the mathematical machinery of statistics . Arrays are much rarer, but worth being aware of.

Matrices and arrays are created with matrix() and array(), or by using the assignment form of dim():
```{r, echo=TRUE}
#Two scalar arguments to specify rows and columns
a<-matrix(1:6,ncol=3,nrow=2)
a
# one vector argument to describe all dimensions
b<-array(1:12,c(2,3,2))
b
c<-1:6
dim(c)<-c(2,3)
c 

```

length() and names() have high-dimensional generalisations:

1. length() generalises to nrow() and ncol() for matrices, and dim() for arrays
2. names() generalises for rownames() and columns() for matrices, and dimnames(), a list of character vectors, for arrays.

```{r, echo=TRUE}
length(a)

ncol(a)

length(b)
```



c() generalises to cbind() and rbind() for matrix or array using is.matrix() and is.array(), or by looking at the length of the dim(). as.matrix() and as.array() make it easy to turn an existing vector into a matrix or array.

Vectors are not the only 1-dimensional data structure. You can have matrics with a single row or single column,. or arrays with a single dimension. They may print similaryly, but will behave differently. The differencws aren't too important, but it's useful to know they exist in case you get strange output from a function (tapply() is a frequent offender). As always, use str() to reveal the differences.


```{r, echo = TRUE} 
str(1:3) # 1-d vector

str(matrix(1:3,ncol=1)) # column vector

str(matrix(1:3,nrow=1)) # row vector

str(array(1:3,3)) # array vector
```

While atomic vectors are most commonly turned into matrices, the dimension attribute can also be set on lists to make list-matrices or list-arrays.

```{r, echo = TRUE}
l<- list(1:3, 'a', TRUE, 1.0)
dim(l)<c(2,2)
l
str(l)
```


Three are relatively esoteric data structures, but can be useful if you want to arrange objects into a grid-like structure. For example, if you're running models on a spatio-temporal grid, it might be natural to preserve the grid structure by storing the models in a 3d array.


## 2.4 Data frames

A data frame is the most common way of storing data in R, and if used systematically makes data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list. This means that a data frame has names(), colnames(), and rownames(), although names() and colnames() are the same thing. The length() of a data frame is the length of the underlying list and so is the same as ncol(); nrow() gives the number rows.

### 2.4.1 Creation

You create a data frame using data.frame(), which takes named vector as input:

```{r, echo=TRUE}

df<-data.frame(x = 1:3, y = c('a','b','c'))
df
str(df)
```

Beware data.frame()'s default behaviour which turns strings into factors. Use StringAsFactors = False to suppress this behaviour:

```{r,echo = TRUE}
df<-data.frame(x = 1:3, y = c('a','b','c'), stringsAsFactors = FALSE)

str(df)

```

### 2.4.2 Testing and coercion

Because a data.frame is an S3 class. Its type refects the underlying vector used to build it: the list. To check if an object is a data frame, use class() or test explicitly with is.data.frame().

```{r,echo = TRUE}
typeof(df)

class(df)

is.data.frame(df)
```

You can coerce an object to a data frame with as.data.frame():

A vectore will create a one-column data frame.

A list will create one column for each element; it's an error if they're not all the same lenght.

A matrix will create a data frame with the same number of columns and row as the matrix.

### 2.4.3 Combining data frames

You can combine data frames using cbind() and rbind():

```{r, echo = TRUE}
cbind(df, data.frame(z = 3:1))

rbind(df,data.frame(x = 10, y = 'z'))
```

When combining column-wise, the number of rows must match, but row names are ignored. When combining row_wise, both the number and names of columns must match. Use plyr: :rbind.fill() to combine data frames that don't have the same columns.


It's a common mistake to try and create a data frame by cbind()ing vectors together. This doesn't work because cbind() will create a matrix unless one of the arguments is already a data frame. Instead use dta.frame() directly:

```{r,echo = TRUE}

bad<-data.frame(cbind(a = 1:2, b = c('a','b')), stringAsFactors = F)

good<-data.frame(a = 1:2, b = c('a','b'), stringAsFactor = F)

str(bad)

str(good)


```

### 2.4.4 Special columns

Since a data frame is a list of vectors, ist is possible for a data frame to have a column that is as list:


```{r, echo = TRUE}
 df<-data.frame(x = 1:3)
df$y<-list(1:2,1:3,1:4)
df
```

However, when a list is given to data.frame(), it tries to put each item of the list into its own column, so this fails


 data.frame(x = 1:3, y = list(1:3,2:3,1:4))
Error in data.frame(1:3, 2:3, 1:4, check.names = FALSE, stringsAsFactors = TRUE) : 
  arguments imply differing number of rows: 3, 2, 4
A workaround is to use I(), which causes data.frame() to treat the list as one unit:

```{r, echo=TRUE}
dfl<-data.frame(x = 1:3, y = I(list(1:2,1:3,1:4)))

str(dfl)

dfl[2,'y']
```

I() adds the AsIs class to its input, but this can usually be safely ignored.

Similarly, it's also possible to have a column of a data frame that's a matrix or array , as long as the number of rows match the data frame.

```{r, echo = T}
dfm<- data.frame(x = 1:3, I(matrix(1:9, nrow = 3)))

str(dfm)

dfm
```

Use list and array column with caution: many functions that work with data frames assume that all columns are atomic vectors.


# 3. Subetting
R's subsetting operations are powerful and fast. Mastery of subsetting allows you to succinctly express complex operations in a way that few other languages can match. Subetting is hard to learn because you need to master a number of interrelated concepts:

1. The three subsetting operators.
2. The six types of subetting.
3. Important differences in behaviour for different objects (e.g. vectors, lists, factors, matrices, and data frames)
4. The use of subsetting in conjunction with assignment.

## 3.1 Data types 

It's easy to learn how subetting works for a atomic vectors, and then how it generalises to higher dimensios and other more complicated objects. We'll start with [, the most commonly used operator. Section 3.2 will cover [[ and $ two other main subsetting operators.

### 3.1.1 Atomic vectors
Let's explore the different types of subsetting with a simple vector, x.

```{r, echo = T}
x<-c(2.1, 4.2, 3.3, 5.4)
```
Note the number after the decimal point gives the original position in the vector.

There are five things that you can use to subset a vector:

1. Positive integers return elements at the specified positions:
```{r, echo = T}
x[c(3,1)]

order(x)

x[order(x)]

# Duplicated indices yield duplicated values
x[c(1,1)]

#Real numbers are silently truncated to integers

x[c(2.1,2.9)]

```

2. Negative integers omit elements at the specified positions:
```{r, echo = T}
x[-c(3,1)]

# You can't mix positive and negative integers in a single subset:
#x[c(-1,2)]
#Error in x[c(-1,2)]: only 0's may be mixed with negative subscripts
```

3. Logical vectors select elements where the corresponding logical value is TRUE. This is probably the most useful type of subsetting because you write the expression that creates
the logical vector:

```{r, echo = TRUE}
x[c(TRUE,TRUE,FALSE,FALSE)]

x[x>3]

```
If the logical vector is shorter than the vector being subsetted, it will be recycled to be the same length.

```{r, echo = TRUE}
x[c(TRUE, FALSE)]

# which is wquivalent to 
x[c(TRUE,FALSE,TRUE,FALSE)]

```

A missing value in the index always yields a missing value in the output:
```{r, echo = TRUE}
x[c(TRUE,TRUE,NA,FALSE)]
```

Nothing returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and array. it can also useful in cojunction with assignment.

4. Nothing returns the original vector. This is not something you usually do on purpose, but it can be helpful for generating test data.

```{r, echo = TRUE}
x[]
```

5. Zero returns a zero-length vector. This is not something you usually do on purpose, but it can be helpful for generating test data.

```{r, echo = TRUE}
x[0]
```

5. Character vectors to return elements with matching names.

```{r, echo = TRUE}
y <-setNames(x,letters[1:4])

y[c('d','c','a')]

# Like integer indices, you can repeat indices
y[c('d','d','d')]

# when subsetting with [, names are always matched exactly

z<-c(abc = 1, def = 2)
z[c('a','d')]
```

### 3.1.2 Lists
Subsetting a list works in the same way as subsetting an atomic vector. Using [ will always return a list; [[ and $, as described below , let you pull out the components of the list.


### 3.1.3 Matrices and arrays

You can subset higher-dimensional structures in three ways:

1. with multiple vectors.
2. with a single vector.
3. with a matrix

The most commmon way of subsetting matrices(2d) and arrays(>2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comman. Blank subsetting is now useful because it lets yu keep all rows or all columns.

```{r, echo = TRUE}
a<-matrix(1:9, nrow = 3)

colnames(a)<-c('A','B','C')

a[1:2,1]

a[c(T,F,T),c('B','A')]

a[0,-2]
```

By default, [ will simplify the results to the lowest possible dimensionality. See section 3.2.1 to learn how to avoid this.

Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they wil behave like a vector. Arrays in R are stored in column-major order:

```{r, echo = TRUE}
vals <-outer(1:5,1:5, FUN = 'paste', sep = ',')

vals

vals[c(4,15,16,17,18)]
```


You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value,where each column corresponds to a dimension in the array being subsetted. This means that youi use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The results is a vector of values:

```{r, echo = TRUE}
Vals<-outer(1:5, 1:5, FUN ='paste', sep = ",")
select <-matrix(ncol =  2, byrow=T, c(1,1,3,1,2,4))
vals
select
vals[select]
```


### 3.1.4 Data frames

Data frames posses the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they bechave like matrices.

```{r, echo = T}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df 

df[df$x==2]

df[c(1,3),]

# there are two ways to select columns froma data frame
# like a list

df[c('x','z')]

#like a matrix
df[,c('x','z')]

# there is an important difference if you select a single column: matrix subsetting simplifies by default, list subsetting does not.

df['x']

str(df['x'])


df[,'x']
str(df[,'x'])


```


### 3.1.5 S3 objects

S3 objects are made up of atomic vectors, arrays, and lists, so you can always pull apart an S3 object using techniques described above and the knowledge you gain from str().

### 3.1.6 S4 objects

There are also two additional subsetting operators that are needed for S4 objects: @(equivalent to $) and slot() (equivalent to [[). @ is more restrictive than $ in that it wil return an error if the slot does not exist. These are described in more detail in Section 7.3

## 3.2 Subsetting operators

There are two other subsetting operators. [[ and $. [[ is similar to [, except it can only return a single value and it allows you to pull pieces out of a list. $ is a useful shorthand for [[ combined with character subsetting.

You need [[ when owrking with lists. This is because when [ is applied to a list it always returns a list: it never gives yu the contents of the list. To get the contents , you need [[:

"If list x is a train carring objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6"  --RLangTip

Because it can return only a single value, you must use [[ with either a single positive integer or a string:


```{r, echo = T}
a<-list(a = 1, b = 2)
a[[1]]

# if you do supply a vector it indexes recursively 

b<- list(a = list(b = list(c= list(d = 1))))

b[[c('a','b','c','d')]]

# same as
 b[['a']][['b']][['c']][['d']]
```
Because data frames are lists of columns, you can use [[ to extract a column from data frames: mtcars[[1]], mtcars[['cyl']].

S3 and S4 objects can override the standard behaviour of [ and [[ so they behave differently for different types of objects. The key difference is usually how you select between simplifying or preserving behaviours and what the default is.

### 3.2.1 

It's important to understand the distinction between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. Preserving subsetting keeps the structre of the output the same as the input, and is generally better for programming because the result will always be the same type. Omitting drop = FALSE when subsetting matrices and data frames is one of the most common sources of programming errors. (it will work for your test cases, but then some one will pass in a single column data frame and it will fail in an unexpected and unclear way.)

Unfortunately, how you switch between simplifying and preserving differs for different data types , as summarised in the table below.

vector:
simplifying: x[[1]]
preserving: x[1]

list:
simplifying: x[[1]]
preserving: x[1]

factor:
simplifying: x[1:4, drop = T]
preserving: x[1:4]

array:
simplifying: x[1,] or x[,]
preserving: x[1,, drop = F] or x[,1,drop=T]

data frame:
simplifying: x[,1] or x[[1]]
preserving: x[,1,drop = F] or x[1]


Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below

```{r, echo = T}
# atomic vector: removes names.

x<-c(a = 1, b = 2)

x[1]
str(x[1])

x[[1]]
str(x[[1]])
#List: return the object inside the list, not a single element list.

y<-list(a = 1, b = 2)

y[1]
str(y[1])

y[[1]]

str(y[[1]])

#Factor: drops any unused levels:

z<-factor(c('a','b'))
z[1]
str(z[1])

z[1,drop = T]

str(z[1,drop =T])


# Matrix or array: if any of the dimensions has length 1, drops that dimensions.

a<-matrix(1:4, nrow = 2)
a
a[1,,drop = F]
str(a[1,,drop = F])
a[1,]
str(a[1,])

#Data frame: if output is a single colukn, returns a vector instead of a dataframe

df<-data.frame(a = 1:2,b =1:2)
df
df[1]
str(df[1])
df[[1]]
str(df[[1]])
df[,'a',drop = F]
str(df[,'a',drop=F])
df[,'a']
str(df[,'a'])
```

### 3.2.2 $

$ is a shorthand operator , where x$y is equivalent to x[['y',exact = F]]. It's often used to access variable in a data frame, as in mtcars$cyl or diamonds$carat.

One common mistake with $ is to try and use it when you have the name of a column stored in a variables:

Var<-'cyl'

Doesn't work - matcars$var translated to mtcars[['var']]

instead use [[

mtcars[[var]]
There is one important difference between $ and [[. $ does partial matching:

```{r, echo = T}
x<-list(abc = 1)

x$a

x[['a']]
```

If you want to avoid this behaviour you can get the global option warPartialMatchDollar to TRUE. Use with caution: It may behaviour in other code you have loaded.

### 3.2.3 Missing/out of bounds indices

[ and [[ differ slightly in their behaviour when the index is out of bounds (OOB), for example, when you try to extract the fifth element of a length four, or subset a vector with NA or NULl.

```{r}
x<-1:4

str(x[5])

str(x[NA_real_])

str(x[NULL])

```

## 3.3 Subsetting and assignment

All subsetting operators can be combined with assignemnt to modify selected values of the input vector.

```{r, echo = T,error=TRUE}
x<-1:5

x[c(1,2)]<-2:3
x

# The length of the LHS needs to match the RHS

x[-1]<-4:1
x

# Note that there's no checking for duplicate indices
x[c(1,1)]<-2:3
x

# you can't combine integer indices with NA
x[c(1,NA)]<-2:3

# But you can combine logical indices with NA (where they're treated as false)

x[c(T,F,NA)]<-1

# This is mostly useful when conditionally modifying vectors

df<-data.frame(a = c(1,10,NA))
df$a[df$a<5]<-0
df$a

```

Subsetting with nothing can be useful in conjunction with asignment because it will preserve the original object calss and structure. Compare the following two expressions. In the first, mtcars will remain as a data frame. In the second mtcars will become a list.

mtcars[] <- lapply(mtcars, as.integer)
mtcars<lapply(mtcars, as.integer)

With lists, you can use subsetting + assignment + NULL remove components from a list. To add a literal NULL to a list, use [ and list(NULL):

```{r, echo = T}
x<-list(a = 1, b=2)

x[['b']]<-NULL

str(x)

y<-list(a = 1)

y['b']<-list(NULL)

str(y)
```

## 3.4 Applications

The basic priciples described above give rise to a wide variety of useful applications. Some of the most important are described below. Many of these basic techniques are wrapped up into more concise functions(e.g.subset(), merge(), plyr::arrange()), but it is useful to understand how they are implemented with basic subsetting. This will allow you to adapt to new situations that are not dealt with by existing functions.

### 3.4.1 Lookup tables(character subsetting)

Character matching provides a powerful way to make lookup tables. Say you want to convert abbreviations:

```{r, echo = T}
x<-c('m','f','u','f','f','m','m')
lookup<-c(m='Male',f = 'Female', u = NA)
lookup
lookup[x]

unname(lookup[x])

#or with fewer output values 
c(m = 'known', f = 'known', u = 'unknown')[x]

```

If you don't want names in the result, use unname() to remove them.

### 3.4.2 Matching and merging by hand (integer subsetting)

You may have a more complicated lookup table which has multiple columns of information. SUppose we have a vector of integer grades, and a table that describes their properties:

```{r, echo = T}

grades<-c(1,2,2,3,1)

info <- data.frame(grade = 3:1,
                   desc = c('Excellent','Good','Poor'),
                   fail = c(F,F,T))

```

We want to duplicate the info table so that we have a row for each value in grades. We can do this in two ways, either using match() and integer subsetting, or rownames() and character subsetting:

```{r, echo = T}
id <- match(grades, info$grade)
id
info[id,]
```

### 3.4.3 Random samples/bootstrap (integer subsetting)

You can use integer indices to perform random sampling or bootstraping of a vector or data frame. sample() generates a vector of indices, then subsetting to access the values:

```{r, echo = T}

df<-data.frame(x = rep(1:3, each =2), y = 6:1, z = letters[1:6])

# set seed for reproducibility

set.seed(10)

# randomly recorder

df[sample(nrow(df)),]

# select 3 random rows

df[sample(nrow(df),3),]

# select 6 bootstrap replicates

df[sample(nrow(df),6,rep = T),]
```

The arguments of sample() control the number of samples to extract, and whether sampling is performed with or without replacement.

### 3.4.4 Ordering (integer subsetting)

order() takes a vector as input and returns an integer vector describing how the subsetted vectore should be ordered:

```{r, echo = T}
x<-c('b','c','a')

order(x)

x[order(x)]
```

To break ties, you can supply additional variables to order(), and you can change from ascending to descending order using decreasing = TRUE. By default, any missing values will be put at the end of the vector; however, you can remove them with na.last = NA or put at the front with na.last = FALSE.

For two or more dimensions, order() and integer subsetting makes it easy to order either the rows or columns of an object:

```{r, echo = T}

df2<-df[sample(nrow(df)),3:1]
df2
df2[order(df2$x),]
df2[,order(names(df2))]

```

MOre concise, but less flexible, functions are avaiable for sorting vectors, sort(), and data frames, plyr:: arrange().

### 3.4.5 Expanding aggregated counts (integer subsetting)

Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. rep() and integer subsetting make it easy to uncollapse the 
data by subsetting with a repeasted row index:

```{r,echo = TRUE}
df<-data.frame(x = c(2,4,1), y = c(9,11,6),n = c(3,5,1))
rep(1:nrow(df),df$n)
df[rep(1:nrow(df),df$n),]
```

### 3.4.6 Removing columns from data frames (character subsetting)

There are two ways to remove columns from a data frame. You can set individual columsn to NULL:

```{r, echo = TRUE}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df$z<-NULL

df
```
Or you can subset to return only the columns you want:

```{r, echo = T}
df<-data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df[c('x','y')]

```

If you know the columns you don't want, use set operations to work out which columns to keep:

```{r, echo = T}
df[setdiff(names(df),'z')]
```

### 3.4.7 Selecting rows based on a condition (logical subsetting)

Because it allows you to easily combine conditions from multiple columns, logical subsetting is probably the most commonly used technique for extracting rows out of a data frame.

```{r, echo = T}
mtcars[mtcars$gear == 5,]

mtcars[mtcars$gear == 5 & mtcars$cyl == 4,]
```

Remember to use the vector boolean operators & and |, not the shortcircuiting scalar && and || which are more useful inside if statements. Don't foget De Morgan's laws, whcih can be useful to simplify negations:

!(X & Y) is the same as !X | !Y
!(X | Y) is the same as !X & !Y

For example, !(X & !(Y | Z)) simplifies to !X | !!(Y | Z), and then to !X | Y | Z.

subset() is a specilised shorthand function for subsetting data frame and saves some typing because you don't need to repeat the name of the data frame. You'll leanr how it works in Chapter 13.

```{r, echo = TRUE}
subset(mtcars, gear ==5)

subset(mtcars, gear == 5 & cyl == 4)
```

### 3.4.8 Boolean algebra vs. sets (logical & integer subsetting)

It's useful to be aware of the natural equivalence between set operations (integer subsetting) and boolean algebra (logical subsetting). Using set operations is more effective when:

1. You want to find the first (or last) TRUE.
2. You have very few TRUEs and very many FALSEs; a set representation may be faster and require less storage.

Which() allows you to convert a boolean representation to an integer representation. There's no reverse operation in Base R but we can easily create one:

```{r, echo = T}
x<-sample(10)<4
x
which(x)

unwhich<-function(x,n){
  out<-rep_len(FALSE,n)
  out[x]<-TRUE
  out
}
unwhich(which(x),10)
```

Let's create two logical vectors and their integer integer equivalents and then explore the relationship between boolean and set operations.


```{r, echo = T}
(x1<-1:10 %% 2 ==0)

(x2<-which(x1))

(y1<-1:10 %% 5 == 0)

(y2<-which(y1))

x1 & y1

intersect(x2, y2)

x1 | y1

union(x2, y2)

x1 &! y1

setdiff(x2, y2)

xor(x1,y1)

setdiff(union(x2,y2),intersect(x2,y2))
```

When first learning subsetting, a common mistake is to use x[which(y)] instead of x[y]. Here the whihc() achieves nothing: it switches from logical to integer subsetting but the result will be exactly the same. Also beware that x[-which(y)] is not equivalent to x[!y]: if y is all FALSE, which(y) will be integer(0) and -integer(0) is still integer(0), so you'll get no values, instead of all values. In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last TRUE value.


# 4. Vocabulary 

An important part of being fluent in R is having a good working vocabulary. Below, I have listed the functions that I believe constitute such a vocabulary. You don't need to be intimately familiar with the detail of every function, but you should at least be aware that thaey all exist. If there are functions in the list that you've never heard of , I strongly recommend that you read their documentation.

I came up with this list by looking through all the functions in the base, stats and utils packages, and extracting those that I think are most useful. THe list also includes a few pointer to particularly important functions in other packages, and some of the more important options().

## 4.1 The basics

##### 1. The first functions to learn
* ?
* str

##### 2. Important operators and assignment

* %in%, match 
* =, <-,<<-
* $, [, [[, head, tail, subset
* with 
* assign, get

##### 3. Comparison
* all.equal, indentical 
* !=, ==, >, >=, <,<=
* is.na, complete.cases
* is.finite
                                             
##### 4. Math 

* *, +, -, /, %%, %/%
* abs, sign 
* acos, asin, atan, atan2
* sin, cos, tan
* ceiling, floor, round, trunc, signif
* exp, log, log10, log2, sqrt
* max, min, prod, sum
* summax, cummin, cumprod, cumsum, diff
* pmax, pmin
* range
* mean, median, cor, sd, var
* rle

##### 5. Functions to do with functions

* function
* missing
* on.exit
* return, invisible

##### 6. Logical & sets

* &, |, !, xor
* all, any
* intersect, union, setdiff, setequal
* which

##### 7. Vectors and matrices

Automatic coercion rules: character> numeric> logical 

* length, dim, ncol, nrow
* cbind, rbind
* names, colnames, rownames
* t
* dig
* sweep
* as.matrix, data.matrix

##### 8. Making vectors

* c
* rep, 
* rep_len
* seq, seq_len, seq_along 
* rev
* sample
* choose, factorial, combn
* (is/as).(character/numeric/logical/...)

##### 9. List & data.frames

* list, unlist
* data.frame, as.data.frame
* split
* expand.grid

##### 10. Control flow

* if, &&, ||, (short circuiting)
* for, while 
* next, break
* switch
* ifelse

##### 11. Apply & friends

* lapply, sapply, vapply
* apply
* tapply
* replicate

## 4.2 Common data structures 

##### 1. Data time 

* ISOdate, ISOdatetime, strftime, strptime, date
* difftime
* julian, months, quarters, weekdays
* library(lubridate)

##### 2. Character manipulation

* grep, agrep
* gsub
* strsplit
* chartr
* nchar
* tolower, toupper
* substr
* paste
* library(stringr)

##### 3. Factors

* factor, levels, nlevels
* reorder, relevel
* cut, findInterval
* interaction
* option(stringsASFactors = False)

##### 4. Array manipulation

* array
* dim
* dimnames
* aperm
* library(abind)

## 4.3 Statistics

##### 1. Ordeing and tabulating 

* duplicated, unique
* merge
* order, rank, quantile
* sort
* table, ftable

##### 2. Linear models

* fitted, predict, resid, rstandard
* lm,glm 
* hat, influence, measures
* logLik, df, deviance
* formula, ~, I
* anova, coef, confint, vcov
* contrasts

##### 3. Miscellaneous tests

* apropos('\\.test$')

##### 4. Random variables

* (q, p, d, r) * (beta, binom, cauchy, chisq, exp, f, gamma, geom, hyper, lnorm, logis, multinom, nbinom, norm, pois, signrank, t, unif, weibull, wilcox, birthday, tukey)

##### 5. Matrix algebra 

* corssprod, tcrossprod
* eigen, qr, svd,
* %*%, %o%, outer
* rcond
* solve

## 4.4 WOrking with R

##### 1. Workspace

* ls, exists, rm
* getwd, setwd
* q
* source
* install.packages, library, require

##### 2. Help 

* help, ?
* help.search
* apropos
* RSiteSearch
* citation
* demo
* example
* vignette

##### 3.Debugging

* traceback
* browser
* recover
* options(error = )
* stop, warning, message
* tryCatch, try

## 4.5 I/O

##### 1. Output

* print, cat
* message, warning
* dput
* format
* sink, capture.output

##### 2. Reading and writing data

* data
* cout.fields
* read.csv, write.csv
* read.delim, write.delim
* read.fwf
* readLines, writeLines
* readRDS, saveRDS
* load, save
* library(foreign)

##### 3. Files and directories

* dir
* basename, dirname, tools::file_ext
* file.path
* path.expand, normalizePath
* file.choose
* file.copy, file.create, file.remove, file.rename, dir.create
* file.exists, file.info
* tempdir, tempfile
* download.file, library(downloader)

# 5. Style guide 

Good coding style is like using correct punctuation. You can manage without it, but it si sure makes things easier to read. As with styles of punctuation, there are many possible variations. The following guide describes the style that I use (in this book and elsewhere). It is based on Google's R style guide (https://google.github.io/styleguide/Rguide.xml), with a few tweaks. You don't have to use my style, but you really should use a consistent style.

GOod style is important because while your code only has one author, it'll usually have multiple readers. This is especially true when you're  writing code with others. In that case, it's a good idea to agree on a common style up-front. Since no styles is strictly better than another, working with others may mean that you'll need to sacrifice some preferred aspects of your style.

The formatR package, by Yihui Xie, makes it easier to clean up poorly formatted code. It can't do everything, but it can quickly get your code from terrible to pretty good. Make sure to read the introduction before using it.

## 5.1 Notation and naming

### 5.1.1 File names

File names should be meaningful and end in .R

**Good**

* fit-models.R
* utility-functions.R

**Bad**

* foo.r
* stuff.r

If files need to be run in sequence, prefix them with numbers:

* 0-download.R
* 1-parse.R
* 2-explore.R

### 5.1.2 Object names

"There are only two hard tings in Computer Sciense: cache invalidation and naming things." -Phil Karlton

Variable and function names should be lowercase. Use an underscore(_) to separate words within a name. Generally, vairable names should be nouns and function names should be verbs. Strive for names that are concise and meaning ful(this is not easy!)

**Good**

* day_one
* day_1

**Bad**

* first_day_of_the_month
* DayOne
* dayone
* djm1

Where possible, avoid using names of existing functions and variables, This will cause confusion for the readers of your code.

## 5.2 Syntax 

### 5.2.1 Spacing

Place spaces around all infix operators(=, +, -, <-,etc.). The same rule applies when using = in function calls. Always put a space after a comma, and never before (just like in regular English).

**Good**
average <- mean(feet / 12 + inches, na.rm = TRUE)

**Bad**
average<-mean(feet/12+inches, na.rm=TRUE)

There is a small exception to this rule: :, :: and ::: don't need spaces around them.

**Good**
x <- 1:10

**Bad**
x <-1 : 10

Place a space before left parentheses, except in a function call.

**Good**
if (debug) do(x)
plot(x, y)

**Bad**
if(debug)do(x)
plot (x, y)

Extra spacing (i.e., more than oen sapce in a row) is ok if it improves alignment of equal signs or asignments(<-).

list(
  total = a + b + c 
  mean = (a + b + c) / n
)

Do not place spaces around code in parentheses or square brackets, unless there's a comma, in which case see above).

**Good**
if (debug) do(x)
diamonds[5, ]

**Bad**
if ( debug )  do(x)
x[1,]
x[1 ,]

### 5.2.2 Curly braces

An opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line, unless it's followed by else.

Always indent the code inside curly braces.

**Good**

if (y < 0 && debug) {
 message("Y is negative")
}

if (y == 0) {
  log(x)
} else {
  y ^ x
}


### 5.2.3 Line lenght 

Strive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font. If you find yourself running out of room, this is a good indication that you should encapsulate some of the work in a separate function.

### 5.2.4 Indentiation

When indenting your code, use two spaces. Never use tabs or mix tabs and spaces.

The only exception is if a function definition rusn over multiple lines. In that cases, indent the second line to where the definition starts:

long_function_name <- function(a = 'a long argument',
                               b = 'another argumnt',
                               c = 'another long argument') {
  as usual code is indented by two spaces,                               
}

### 5.2.5 Assignment 

Use <-, not - , for assigment,

**Good**

x <- 5

**Bad**

x = 5

## 5.3 Organisation 

### 5.3.1 COmmenting guidelines

COmment your code. Each line of a comment should begin with the comment symbol and a single space: #. COmments should explain the why, not the waht.

Use commented lines of - and = to break up your file into easily readable chunks.

# 6 Functions

Functions are fundamental building block or R: to master many of the more advanced technique in thsi book, you need a solid foundation in how function work. You've probably already created many R functions, and you're familiar with the basics of how they work. The focus of this chapter is to turn your existing, informal knowledge of functions into a rigorous understanding of what functions are and how they work. You'll see some interesting tricks and techniques in this chapter, but most of what you'll learn will be more important as the building blocks for more advanced techniques.

The most important thing to understand about R is that function are objects in their own right. You can work with them exactly the same way you work with any other type of object. This theme will be explored in depth in chapter 10.

## 6.1 Function components

All R function have three parts.

** the body(), the code inside the function.

** the formals(), the list of arguments which controls how you can call the function.

** the environment(), the 'map' of the location of the function's variables.

When you print a function in R, it shows you these three important components. If the environment isn't displayed, it means that the function was created in the global environment. 

```{r, echo = TRUE}

f <- function(x) x^2 

formals(f)

body(f)

environment(f)
```

The assignment forms of boday(), formals(), and environment() can also be used to modify functions. 

Like all objects in R, functions can also possess any number of additional attributes(). One attribute used by base R is "Srcref", short for source reference, which points to the source code used to create the function. Unlike body(), this contains code comments and other formatting. You can also add attributes to a function. For example, you can set the class() and add a custom print() method.

### 6.1.1 Primitive functions

There is one exception to the rule that functions have three components. Primitive functions, like sum(), call C code directly with .Primitive() and contain no R code. Therefore their formals(), body(), and environemnt() are all NULL.

```{r, echo = TRUE}
body(sum)
formals(sum)
environment(sum)
attributes(sum)
```

Primitive functions are only found in the base packages, and since they operate at a low level, they can be more efficient (primitive replacement functions don't have to make copies), and can hae different rules for argument mathcing (e.g., switch and call). This, however, comes at a cost of behaving differently from all other functions in R. Hence the R core team generally avoids createing them unless there is no other option.

## 6.2 Lexical scoping

Scoping is the set of rules that govern how R looks up the value of a symbol. In the example below, scoping is the set of rules that R applies to go from the symbol x to its value 10:

```{r, echo = TRUE}
x <- 10 

x
```

Understanding scoping allows you to: 

** build tools by composing functions, as described in Chapter 10.

** overrule the usual evaluation rules and do non-standard evaluation, as described in Chapter 13.

R has two types of scoping: **Lexical scoping**, implemented automatically at the language level, and **dynamic scoping**, used in select functions to save typing during interactive analysis. We discuss lexical scoping here because it is intimately tied to function creation. Dynamic scoping is described in more detail in Section 13.3.

Lexical scoping looks up symbol values based on how function were nested when they were created, not how they are nested when they are called. With lexical scoping, you don't need to know how the function is called to figure out where the value of a variable will be looked up. You just need to look at the function's definition.

The 'lexical' in lexical scoping doesn't correspond to the usual English defintion ('of or realting to words or the vocabulary of a language as distinguished from its grammer and construction') but comes from the computer science term 'lexing', which is part of the process that converts code represented as text to meaningful pieces that the programming language understand.

There are four basic principles behind R's implementation of lexical scoping:

* name masking
* function vs. variables
* a fresh start
* dynamic lookup

You probably know many of these principles already, althought you might not have thought about them explicitly. Test your knowledge by mentally running through the code in each block before looking at the answers.


### 6.2.1 Name masking
The following example illustrate the most basic principle of lexical scoping, and you should have no problem predicting the output.

```{r, echo = TRUE}
f <- function() {
  x <- 1
  y <- 1
  c(x, y)
}
f()
rm(f)
```

If a name isn't defined inside a function, R will look one level up.

```{r, echo = TRUE}
x <- 2
g <- function() {
  y <- 1
  c(x, y)
}
g()
rm(x, g)
```

The same rules apply if a function is defined inside another function: look inside the current function, then where that function was defined, and so on, all the way up to the global environment, and then on to other loaded packages. Run the following code in you head, then confirm the output by running the R code.

```{r, echo = TRUE}
x <- 1

h <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
h()
rm(x, h)
```

The same rules apply to closure, functions created by other functions. Closures will be described in more detail in Chapter 10; here we'll just look at how they interact with scoping. The following function, j(), returns a function. What do you thing this function will return when we call it?

```{r, echo = TRUE}
j <- function(x) {
  y <- 2
  function() {
    c(x, y)
  }
}

k <- j(1)
k()
rm(j, k)
```

This seems a little magical (how does R know what the value of y is after the function has been called). It works because k preserves the environment in which it was defined and because the environment includes the value of y. Chapter 8 gives some pointers on how you can dive in and figure out what values are stored in the environment associated with each function.

### 6.2.2 Functions vs. variables

The same principles apply regardless of the type of associated value finding functions works exactly the same way as finding variables:

```{r, echo = TRUE}
l <- function(x) x + 1 
m <- function() {
  l <- function(x) x * 2 
  l(10)
}
m()
rm(m, l)
```

For functions, there is one small tweak to the rule. If you are using a name in a context where it's obvious that you want a function (e.g., f(3)), R will ignore objects that are not functions while it is searching. In the following example n takes on a different value depending on whether R is looking for a function or a variable.

```{r, echo = TRUE}

n <- function(x) x / 5

o <- function() {
  n <- 10 
  n(n)
}

o()
rm(o)
```

However, using the same name for function and other objects will make for confusing code, and is generally best avoided

### 6.2.3 A fresh start

What happens to the values in between invocation of a function? What will happen the first time you run this function? What will happen the second time? (If you haven't seen exists() before: it returns TRUE if there's a variable of that name, otherwise it returns FALSE).
 
 
```{r, echo = TRUE}
j <- function() {
  if (!exists('a')){
    a <- 1
  } else {
  a <- a + 1
  }
  print(a)
}

j()
j()
rm(j)


```

You might be surprised that it returns the same value, 1, every time. This is because every time a function is called, a new environment is created to host executio. A function has no way to tell what happened the last time it was run; each invocation is completely independent. (We'll see some ways to get around this in Section 10.3.2)

### 6.2.4 Dynamic lookup 

Lexical scoping determines where to look for values, not when to look for them. R looks for values when the function is run, not when it's created. This means that the output of a function can be different depending on objects outside its environment:

```{r, echo = TRUE}
f <- function() x
x <- 15
f()

x <- 20 
f()

```

You generally want to avoid this behavior because it means the function is no longer self-contained. This is a common error -- if you make a spelling mistake in you code, you won't get an error when you create the function, and you might not even get one when you run the function, depending on what variable sare defined in the global environment.

One way to detect this problem is the findGlobals() function from codetools. This function lists all external dependencies of a function:

```{r, echo = TRUE}
f <- function() x + 1
codetools::findGlobals(f)
```

Another way to try and solve the problem would be manually change the environment of the function to the emptyenv(), an environment which contains absolutely nothing:
```{r, echo = TRUE, error = TRUE}

environment(f) <- emptyenv()
f()

```

This doesn't work because R relies on lexical scoping to find everythin even the '+' operator. It's never possible to make a function completely self-contained because you must always rely on functions defined in base R or other packages. 

You can use this same idea to do other things that are extremely ill-advised. For examples, since all of the standard operators in R are functions, you can override them with your own alternatives.

```{r, echo = TRUE}

'(' <- function(el) {
  if (is.numeric(el) && runif(1) < 0.1) {
    el + 1
  } else {
    el
  }
}

replicate(50,(1 + 2)) 
rm('(')
```
This will introduce a particularly pernicious bug: 10% of the time, 1 will be added to any numeric calculation inside parenthese. This is another good reason to rgularly restart with a clean R session !
## 6.3 Every operation is a function call 

"To understand computations in R, two slogans are helpful:
  * Everything that exists is an object.
  * Everything that happens is a function call"
                    ---John Chambers
The previous example of redefining ( works because every operation in R is a function call, whether or not it look like one. This includes infix operators like +, control flow operators like for, if, and while, subsetting operators like [] and $, and even the curly brace {. This means that each pair of statements in the following example is exactly equivalent. Note that ', the backtick, lets you refer to functions or variables that have otherwise reserved or illegal names:






