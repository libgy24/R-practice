---
title: "R Basics"
output: html_document
---

# 2. Data Structures

## 2.1 Vectors

Two different types of vectors: 
1. atomic vector: all elements of atomic vector must be the same type.
2. list: ELements can have different data types.

### 2.1.1 Atomic vectors

There are 4 common types of atomic vectors:
1. Logical
2. Integers
3. Double (often called numeric)
4. Character 

```{r, echo=TRUE}
dbl_var <- c(1, 2.5, 4.5)

# with the L suffix, you get an integer rahter a double

int_var <-c(1L,6L, 10L)

# Use TRUE and FALSE ( or T and F) to create logical vectors
log_Var <- c(TRUE, FALSE, TRUE)

chr_var <- c('these are', 'some strings')
```

Missing values are specified with NA, which is a logical vector of length 1. NA wiil always be coerced to thye correct type if used inside c(), or you can create NAs of a specific type with NA_real_(a double vector), NA_integer_ and NA_character_

#### 2.1.1.1 Types and tests

Given a vector, you can determine its type with typeof(), or check if it's a specific type with an 'is' function.
is.charachter(), is.double(), is.integer(), is.logical(), or , more generally, is.atomic().

```{r, echo=TRUE}

int_var <- c(1L, 6L, 10L)
typeof(int_var)

is.integer(int_var)

is.atomic(int_var)

dbl_var<-c(1, 2.5, 4.5)
typeof(dbl_var)

is.double(dbl_var)

is.atomic(dbl_var)
```

NB: is.numeric() is a general test for the 'numberliness' of a vector and returns TRUE for both integer and double vecotrs. It is not a specific test for double vectors.

```{r echo = TRUE}
is.numeric(int_var)

is.numeric(dbl_var)
```

#### 2.1.1.2 Coercion

All element sof an atomic vector must be the same type, so when you attempt to combine different type they will be coerced to the most flexible type. Types from least to most flexible are: logical, integer, double, and character.
Explicitly coerce with as.character(), as.double(), as.integer() or as.logical()

### 2.1.2 Lists

Lists are different from atomic vectors becasuse their elements can be of any type, including lists. You construct lists by using list() instead of c():

```{r echo=TRUE}
x<- list(1:3, 'a',c(T, F, T), c(2.3,5.9))
str(x)

```

Lists are somethimes called recursive vectors, because a list can contain other lists. This makes them fundamentally different from atomic vectors.


```{r echo = TRUE}
x<-list(list(list()))
str(x)
is.recursive(x)
```

c() will combine several lists into one. If given a combination of a atomic vectors and lists , c() will coerce the vectors to lists before combining them. Compare the results of list() and c():

```{r echo=TRUE}
x<-list(list(1,2),c(3,4))

y<-c(list(1,2),c(3,4))

x
str(x)

y
str(y)
  
```

The typeof() a list is list. You can test for a list with is.list() and coerce to alist with as.list(). You can turn a list onto an atomic vector with unlist(), If the elements of a list have different types, unlist() uses the same coercion rules as c()

Lists are used to build up many of the more complicated data structures in R, FOr example, both data framesand linear model objects are lists.

## 2.2 Attributes

All objects can have arbitrary additional attributes, used to store metadata about the object. Attributes can be thought of as a named list ( with unique names). Atributes can be accessed individually with attr() or all at once (as a list) with attributes()


```{r, echo=TRUE}
y<-1:10

attr(y, 'my_attribute')<-"This is a vector"

str(attributes(y))
```

The structure() function returns a new object with modified attributes:

```{r, echo = TRUE}
structure(1:10, data_type = "This is a vector")
```

By default, most attributes are lost when modifying a vector.

```{r, echo = TRUE}
attributes(y[1])

attributes(sum(y))
```

The only attributes not lost are the three most important:

1. Names, a character vector giving each element a name.
2. Dimensions, used to turn vectores into matrices and arrays.
3. Class, used to implement the S3 object system.

Each of these attributes has a specific accwssor function to get and set values. When working with these attributes,  use names(x), dim(x) and class(x), not attr(x,'names'), attr(x,'dim') and attr(x, 'class')



#### 2.2.0.1 Names

You can name a vector in three ways:

1. When creating it: x<-c(a=1,b=2,c=3)
2. BY modifyying an existing vector in place: x<-1:3;names(x)<-c('a','b','c')
3. By creating a modified copy of a vector: x<-setNames(1:3,c('a','b','c'))

Not all elements of a vector need to have a name. If some names are missing. names() will return an empty string for those elements. If all names are missing, names(0 will return NULL.

```{r, echo = TRUE}
y<-c(a=1, 2,3)
names(y)

z<-c(1,2,3)

names(z)
```

You can create a new vector without names using unname(x), or remove names in place with names(x)<-NULL

### 2.2.1 Factors

One important use of attributes is to define factors. A factor is a vector that can contain only predefined values, and is used to store categorical data.  Factors are built on top of integer vectors using two attributes: the class(),
'factor', which makes them behave differently from regular integer vectors. and the levels(), which defines the set of allow values.

```{r, echo = TRUE}
x <- factor(c('a','b','a','b'))
x
class(x)
levels(x)

# you cannot use values that are not in the levels.
x[2]<-'c'

x

# you cannot combine factors
c_test<-c(factor('a'),factor('b'))

```

Factors are useful when you know the possible values a variable may take, even if you don't see all values in a given dataset . Using a factor instead of a charactro vector makes it obvious when some groups contains no observations.

```{r, echo=TRUE}
sex_char<-c('m','m','m')

sex_factor<-factor(sex_char,levels=c('m','f'))

table(sex_char)

table(sex_factor)
```

Sometimes when a data frame is read directly from a file, a column you'd thought would produce a numeric vector instead produces a factor. This is caused by a non=numeric value in the column, often a missing value encode in a special way like "." or"-". To remedy the situation , coerce the vector from a factor to a character vector, and then from a character to a double vector.(Be sure to check for missing values after this process.)  Of course, a much better plan is to discover what caused the problem in the first place and fix that; usin the na.strings rgument to read.csv()  is often a good place to start.

## 2.3 Matrices and arrays

Adding a dim() attribute to an atomic vector allows it to behave like a multi-dimensional array. A special case of the array is the matrix. Which has two dimensions. Matrices are used commonly as part of the mathematical machinery of statistics . Arrays are much rarer, but worth being aware of.

Matrices and arrays are created with matrix() and array(), or by using the assignment form of dim():
```{r, echo=TRUE}
#Two scalar arguments to specify rows and columns
a<-matrix(1:6,ncol=3,nrow=2)
a
# one vector argument to describe all dimensions
b<-array(1:12,c(2,3,2))
b
c<-1:6
dim(c)<-c(2,3)
c 

```

length() and names() have high-dimensional generalisations:

1. length() generalises to nrow() and ncol() for matrices, and dim() for arrays
2. names() generalises for rownames() and columns() for matrices, and dimnames(), a list of character vectors, for arrays.

```{r, echo=TRUE}
length(a)

ncol(a)

length(b)
```



c() generalises to cbind() and rbind() for matrix or array using is.matrix() and is.array(), or by looking at the length of the dim(). as.matrix() and as.array() make it easy to turn an existing vector into a matrix or array.

Vectors are not the only 1-dimensional data structure. You can have matrics with a single row or single column,. or arrays with a single dimension. They may print similaryly, but will behave differently. The differencws aren't too important, but it's useful to know they exist in case you get strange output from a function (tapply() is a frequent offender). As always, use str() to reveal the differences.


```{r, echo = TRUE} 
str(1:3) # 1-d vector

str(matrix(1:3,ncol=1)) # column vector

str(matrix(1:3,nrow=1)) # row vector

str(array(1:3,3)) # array vector
```

While atomic vectors are most commonly turned into matrices, the dimension attribute can also be set on lists to make list-matrices or list-arrays.

```{r, echo = TRUE}
l<- list(1:3, 'a', TRUE, 1.0)
dim(l)<c(2,2)
l
str(l)
```


Three are relatively esoteric data structures, but can be useful if you want to arrange objects into a grid-like structure. For example, if you're running models on a spatio-temporal grid, it might be natural to preserve the grid structure by storing the models in a 3d array.


## 2.4 Data frames

A data frame is the most common way of storing data in R, and if used systematically makes data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list. This means that a data frame has names(), colnames(), and rownames(), although names() and colnames() are the same thing. The length() of a data frame is the length of the underlying list and so is the same as ncol(); nrow() gives the number rows.

### 2.4.1 Creation

You create a data frame using data.frame(), which takes named vector as input:

```{r, echo=TRUE}

df<-data.frame(x = 1:3, y = c('a','b','c'))
df
str(df)
```

Beware data.frame()'s default behaviour which turns strings into factors. Use StringAsFactors = False to suppress this behaviour:

```{r,echo = TRUE}
df<-data.frame(x = 1:3, y = c('a','b','c'), stringsAsFactors = FALSE)

str(df)

```

### 2.4.2 Testing and coercion

Because a data.frame is an S3 class. Its type refects the underlying vector used to build it: the list. To check if an object is a data frame, use class() or test explicitly with is.data.frame().

```{r,echo = TRUE}
typeof(df)

class(df)

is.data.frame(df)
```

You can coerce an object to a data frame with as.data.frame():

A vectore will create a one-column data frame.

A list will create one column for each element; it's an error if they're not all the same lenght.

A matrix will create a data frame with the same number of columns and row as the matrix.

### 2.4.3 Combining data frames

You can combine data frames using cbind() and rbind():

```{r, echo = TRUE}
cbind(df, data.frame(z = 3:1))

rbind(df,data.frame(x = 10, y = 'z'))
```

When combining column-wise, the number of rows must match, but row names are ignored. When combining row_wise, both the number and names of columns must match. Use plyr: :rbind.fill() to combine data frames that don't have the same columns.


It's a common mistake to try and create a data frame by cbind()ing vectors together. This doesn't work because cbind() will create a matrix unless one of the arguments is already a data frame. Instead use dta.frame() directly:

```{r,echo = TRUE}

bad<-data.frame(cbind(a = 1:2, b = c('a','b')), stringAsFactors = F)

good<-data.frame(a = 1:2, b = c('a','b'), stringAsFactor = F)

str(bad)

str(good)


```

### 2.4.4 Special columns

Since a data frame is a list of vectors, ist is possible for a data frame to have a column that is as list:


```{r, echo = TRUE}
 df<-data.frame(x = 1:3)
df$y<-list(1:2,1:3,1:4)
df
```

However, when a list is given to data.frame(), it tries to put each item of the list into its own column, so this fails


 data.frame(x = 1:3, y = list(1:3,2:3,1:4))
Error in data.frame(1:3, 2:3, 1:4, check.names = FALSE, stringsAsFactors = TRUE) : 
  arguments imply differing number of rows: 3, 2, 4
A workaround is to use I(), which causes data.frame() to treat the list as one unit:

```{r, echo=TRUE}
dfl<-data.frame(x = 1:3, y = I(list(1:2,1:3,1:4)))

str(dfl)

dfl[2,'y']
```

I() adds the AsIs class to its input, but this can usually be safely ignored.

Similarly, it's also possible to have a column of a data frame that's a matrix or array , as long as the number of rows match the data frame.

```{r, echo = T}
dfm<- data.frame(x = 1:3, I(matrix(1:9, nrow = 3)))

str(dfm)

dfm
```

Use list and array column with caution: many functions that work with data frames assume that all columns are atomic vectors.


# 3. Subetting
R's subsetting operations are powerful and fast. Mastery of subsetting allows you to succinctly express complex operations in a way that few other languages can match. Subetting is hard to learn because you need to master a number of interrelated concepts:

1. The three subsetting operators.
2. The six types of subetting.
3. Important differences in behaviour for different objects (e.g. vectors, lists, factors, matrices, and data frames)
4. The use of subsetting in conjunction with assignment.

## 3.1 Data types 

It's easy to learn how subetting works for a atomic vectors, and then how it generalises to higher dimensios and other more complicated objects. We'll start with [, the most commonly used operator. Section 3.2 will cover [[ and $ two other main subsetting operators.

### 3.1.1 Atomic vectors
Let's explore the different types of subsetting with a simple vector, x.

```{r, echo = T}
x<-c(2.1, 4.2, 3.3, 5.4)
```
Note the number after the decimal point gives the original position in the vector.

There are five things that you can use to subset a vector:

1. Positive integers return elements at the specified positions:
```{r, echo = T}
x[c(3,1)]

order(x)

x[order(x)]

# Duplicated indices yield duplicated values
x[c(1,1)]

#Real numbers are silently truncated to integers

x[c(2.1,2.9)]

```

2. Negative integers omit elements at the specified positions:
```{r, echo = T}
x[-c(3,1)]

# You can't mix positive and negative integers in a single subset:
#x[c(-1,2)]
#Error in x[c(-1,2)]: only 0's may be mixed with negative subscripts
```

3. Logical vectors select elements where the corresponding logical value is TRUE. This is probably the most useful type of subsetting because you write the expression that creates
the logical vector:

```{r, echo = TRUE}
x[c(TRUE,TRUE,FALSE,FALSE)]

x[x>3]

```
If the logical vector is shorter than the vector being subsetted, it will be recycled to be the same length.

```{r, echo = TRUE}
x[c(TRUE, FALSE)]

# which is wquivalent to 
x[c(TRUE,FALSE,TRUE,FALSE)]

```

A missing value in the index always yields a missing value in the output:
```{r, echo = TRUE}
x[c(TRUE,TRUE,NA,FALSE)]
```

Nothing returns the original vector. This is not useful for vectors but is very useful for matrices, data frames, and array. it can also useful in cojunction with assignment.

4. Nothing returns the original vector. This is not something you usually do on purpose, but it can be helpful for generating test data.

```{r, echo = TRUE}
x[]
```

5. Zero returns a zero-length vector. This is not something you usually do on purpose, but it can be helpful for generating test data.

```{r, echo = TRUE}
x[0]
```

5. Character vectors to return elements with matching names.

```{r, echo = TRUE}
y <-setNames(x,letters[1:4])

y[c('d','c','a')]

# Like integer indices, you can repeat indices
y[c('d','d','d')]

# when subsetting with [, names are always matched exactly

z<-c(abc = 1, def = 2)
z[c('a','d')]
```

### 3.1.2 Lists
Subsetting a list works in the same way as subsetting an atomic vector. Using [ will always return a list; [[ and $, as described below , let you pull out the components of the list.


### 3.1.3 Matrices and arrays

You can subset higher-dimensional structures in three ways:

1. with multiple vectors.
2. with a single vector.
3. with a matrix

The most commmon way of subsetting matrices(2d) and arrays(>2d) is a simple generalisation of 1d subsetting: you supply a 1d index for each dimension, separated by a comman. Blank subsetting is now useful because it lets yu keep all rows or all columns.

```{r, echo = TRUE}
a<-matrix(1:9, nrow = 3)

colnames(a)<-c('A','B','C')

a[1:2,1]

a[c(T,F,T),c('B','A')]

a[0,-2]
```

By default, [ will simplify the results to the lowest possible dimensionality. See section 3.2.1 to learn how to avoid this.

Because matrices and arrays are implemented as vectors with special attributes, you can subset them with a single vector. In that case, they wil behave like a vector. Arrays in R are stored in column-major order:

```{r, echo = TRUE}
vals <-outer(1:5,1:5, FUN = 'paste', sep = ',')

vals

vals[c(4,15,16,17,18)]
```


You can also subset higher-dimensional data structures with an integer matrix (or, if named, a character matrix). Each row in the matrix specifies the location of one value,where each column corresponds to a dimension in the array being subsetted. This means that youi use a 2 column matrix to subset a matrix, a 3 column matrix to subset a 3d array, and so on. The results is a vector of values:

```{r, echo = TRUE}
Vals<-outer(1:5, 1:5, FUN ='paste', sep = ",")
select <-matrix(ncol =  2, byrow=T, c(1,1,3,1,2,4))
vals
select
vals[select]
```


### 3.1.4 Data frames

Data frames posses the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists; if you subset with two vectors, they bechave like matrices.

```{r, echo = T}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])

df 

df[df$x==2]

df[c(1,3),]

# there are two ways to select columns froma data frame
# like a list

df[c('x','z')]

#like a matrix
df[,c('x','z')]

# there is an important difference if you select a single column: matrix subsetting simplifies by default, list subsetting does not.

df['x']

str(df['x'])


df[,'x']
str(df[,'x'])


```


### 3.1.5 S3 objects

S3 objects are made up of atomic vectors, arrays, and lists, so you can always pull apart an S3 object using techniques described above and the knowledge you gain from str().

### 3.1.6 S4 objects

There are also two additional subsetting operators that are needed for S4 objects: @(equivalent to $) and slot() (equivalent to [[). @ is more restrictive than $ in that it wil return an error if the slot does not exist. These are described in more detail in Section 7.3

## 3.2 Subsetting operators

There are two other subsetting operators. [[ and $. [[ is similar to [, except it can only return a single value and it allows you to pull pieces out of a list. $ is a useful shorthand for [[ combined with character subsetting.

You need [[ when owrking with lists. This is because when [ is applied to a list it always returns a list: it never gives yu the contents of the list. To get the contents , you need [[:

"If list x is a train carring objects, then x[[5]] is the object in car 5; x[4:6] is a train of cars 4-6"  --RLangTip

Because it can return only a single value, you must use [[ with either a single positive integer or a string:


```{r, echo = T}
a<-list(a = 1, b = 2)
a[[1]]

# if you do supply a vector it indexes recursively 

b<- list(a = list(b = list(c= list(d = 1))))

b[[c('a','b','c','d')]]

# same as
 b[['a']][['b']][['c']][['d']]
```
Because data frames are lists of columns, you can use [[ to extract a column from data frames: mtcars[[1]], mtcars[['cyl']].

S3 and S4 objects can override the standard behaviour of [ and [[ so they behave differently for different types of objects. The key difference is usually how you select between simplifying or preserving behaviours and what the default is.

### 3.2.1 

It's important to understand the distinction between simplifying and preserving subsetting. Simplifying subsets returns the simplest possible data structure that can represent the output, and is useful interactively because it usually gives you what you want. Preserving subsetting keeps the structre of the output the same as the input, and is generally better for programming because the result will always be the same type. Omitting drop = FALSE when subsetting matrices and data frames is one of the most common sources of programming errors. (it will work for your test cases, but then some one will pass in a single column data frame and it will fail in an unexpected and unclear way.)

Unfortunately, how you switch between simplifying and preserving differs for different data types , as summarised in the table below.

vector:
simplifying: x[[1]]
preserving: x[1]

list:
simplifying: x[[1]]
preserving: x[1]

factor:
simplifying: x[1:4, drop = T]
preserving: x[1:4]

array:
simplifying: x[1,] or x[,]
preserving: x[1,, drop = F] or x[,1,drop=T]

data frame:
simplifying: x[,1] or x[[1]]
preserving: x[,1,drop = F] or x[1]


Preserving is the same for all data types: you get the same type of output as input. Simplifying behaviour varies slightly between different data types, as described below

```{r, echo = T}
# atomic vector: removes names.

x<-c(a = 1, b = 2)

x[1]
str(x[1])

x[[1]]
str(x[[1]])
#List: return the object inside the list, not a single element list.

y<-list(a = 1, b = 2)

y[1]
str(y[1])

y[[1]]

str(y[[1]])

#Factor: drops any unused levels:

z<-factor(c('a','b'))
z[1]
str(z[1])

z[1,drop = T]

str(z[1,drop =T])


# Matrix or array: if any of the dimensions has length 1, drops that dimensions.

a<-matrix(1:4, nrow = 2)
a
a[1,,drop = F]
str(a[1,,drop = F])
a[1,]
str(a[1,])

#Data frame: if output is a single colukn, returns a vector instead of a dataframe

df<-data.frame(a = 1:2,b =1:2)
df
df[1]
str(df[1])
df[[1]]
str(df[[1]])
df[,'a',drop = F]
str(df[,'a',drop=F])
df[,'a']
str(df[,'a'])
```

### 3.2.2 $

$ is a shorthand operator , where x$y is equivalent to x[['y',exact = F]]. It's often used to access variable in a data frame, as in mtcars$cyl or diamonds$carat.

One common mistake with $ is to try and use it when you have the name of a column stored in a variables:

Var<-'cyl'

Doesn't work - matcars$var translated to mtcars[['var']]

instead use [[

mtcars[[var]]
There is one important difference between $ and [[. $ does partial matching:

```{r, echo = T}
x<-list(abc = 1)

x$a

x[['a']]
```

If you want to avoid this behaviour you can get the global option warPartialMatchDollar to TRUE. Use with caution: It may behaviour in other code you have loaded.

### 3.2.3 Missing/out of bounds indices

[ and [[ differ slightly in their behaviour when the index is out of bounds (OOB), for example, when you try to extract the fifth element of a length four, or subset a vector with NA or NULl.

```{r}
x<-1:4

str(x[5])

str(x[NA_real_])

str(x[NULL])

```

## 3.3 Subsetting and assignment

All subsetting operators can be combined with assignemnt to modify selected values of the input vector.

```{r, echo = T,error=TRUE}
x<-1:5

x[c(1,2)]<-2:3
x

# The length of the LHS needs to match the RHS

x[-1]<-4:1
x

# Note that there's no checking for duplicate indices
x[c(1,1)]<-2:3
x

# you can't combine integer indices with NA
x[c(1,NA)]<-2:3

# But you can combine logical indices with NA (where they're treated as false)

x[c(T,F,NA)]<-1

# This is mostly useful when conditionally modifying vectors

df<-data.frame(a = c(1,10,NA))
df$a[df$a<5]<-0
df$a

```

Subsetting with nothing can be useful in conjunction with asignment because it will preserve the original object calss and structure. Compare the following two expressions. In the first, mtcars will remain as a data frame. In the second mtcars will become a list.

mtcars[] <- lapply(mtcars, as.integer)
mtcars<lapply(mtcars, as.integer)

With lists, you can use subsetting + assignment + NULL remove components from a list. To add a literal NULL to a list, use [ and list(NULL):

```{r, echo = T}
x<-list(a = 1, b=2)

x[['b']]<-NULL

str(x)

y<-list(a = 1)

y['b']<-list(NULL)

str(y)
```

